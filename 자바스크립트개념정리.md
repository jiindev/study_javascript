# 자바스크립트

## 자바스크립트의 개념 이해

### 자바스크립트의 특징

1. 자바스크립트는 `프토토타입 기반의 객체 기반의 언어`다.
2. 자바스크립트는 `인터프리터 언어`(개발자가 별도의 컴파일 작업을 수행하지 않음)로써, 브라우저에 의해 해석되고 실행된다.
3. `등적 형변환` (값에 따라 변수의 형변환이 자동으로 이루어진다.)
4. `객체 지향형 프로그래밍`, `함수형 프로그래밍`을 모두 표현할 수 있다.
5. 기본적으로 위에서 아래의 순서로 진행한다.
6. 웹에 특화된 언어이다.

### 자바스크립트의 데이터 타입

기본(원시적) 타입: 숫자(Number), 문자열(String), 참거짓(Boolean), null, undefined, (symbol)

참조 타입: 객체, 배열, 함수
(참조 타입은 크기가 가변적이며 변수에는 데이터에 대한 참조만 저장됨)

다른 언어에는 숫자 타입이 다양하지만 자바스크립트엔 number 하나만 있음
정수만을 위한 타입이 없고 모든 수를 실수로 처리

### 변수 선언

var : `함수`를 기준으로 스코프를 가진다.
let/const : `블록`을 기준으로 스코프를 가진다.

### THIS

전역공간에서 this는 `전역객체`를 가리킨다. 브라우저에선 window , node.js에선 global
함수 내부에서 역시 `전역객체`
메소드 호출 시 `메소드를 호출한 주체`
콜백에선 기본적으론 `함수내부에서와 동일, 전역객체`
생성자 함수에선 `인스턴스`
화살표 함수에서의 THIS `상위 스코프의 this`

### 클로저

클로저란, 내부 함수가 외부 함수의 맥락(context)에 접근할 수 있는 것을 의미한다.

```
const func = () => {
    let name = '지인';
    const showName = () => {
        alert(name);
    }
    return showName;
}

const startFunc = func();
startFunc(); //name 변수에 접근하여 지인을 alert으로 띄움
```

함수 내부의 지역 변수들은 해당 함수가 처리되는 동안에만 존재하지만, 자바스크립트에서 함수를 리턴하게 되면 클로저가 형성될 당시의 함수, 함수가 선언된 어휘의 환경 조합의 참조를 기억한다.

### 프로토타입 (중요)

자바스크립트는 `프로토타입 기반의` 객체지향 언어.
클래스 기반의 객체지향 언어는 객체 생성 이전에 클래스를 저의하고 이를 통하여 객체를 생성함.
프로토타입 기반의 객체지향 프로그래밍 언어는 클래스 없이도 객체 생성이 가능하다.

자바스크립트의 모든 객체는 부모 역할을 담당하는 객체와 연결되어 있다.
이것은 객체 지향의 `상속`개념처럼 부모 객체의 프로퍼티, 메소드를 상속받아 사용할 수 있도록 한다.
이 부모 객체를 `프로토타입 객체`라고 한다.

생성자 함수가 있을 때 new 연산자를 써서 instance를 만들면 생성자 함수의 prototype이라고 하는 property가 instance 함수의 `__proto__` 라는 property에 전달이 된다.
즉 생성자 함수의 prototype과 instance의 `__proto__` 라는 property는 같은 객체를 참조.
`__proto__`는 내부 프로퍼티에 접근할 때 이 단어를 생략 가능. (prototype으로 동작하는 것으로 보임)

prototype property는 객체. (concat(), filter(), forEach(), map(), push(), pop()이 담겨 있음 = 배열 메서드)

#### 생성자 함수의 prototype에 접근하는 법

- [CONSTRUCTOR].prototype
- [instance].`__proto__`
- [instance]
- Object.getPrototypeOf([instance])
  <br/>

#### 생성자 함수에 접근하는 법

- [CONSTRUCTOR]
- [CONSTRUCTOR].prototype.constructor
- (Object.getPrototypeOf([instance])).constructor
- [instance].`__proto__`.constructor
- [instance].constructor

### 메소드 상속 및 동작 원리

```
function Person(n, a){
    this.name = n;
    this.age = a;
}
Person.prototype.setOlder = function() {
    this.age += 1;
}
Person prototype.getAge = function(){
    return this.age;
}

let jiin = new Person('지인', 58);
let baby = new Person('아기', 1);

jiin.__proto__.setOlder();
=> jiin.setOlder();
```

각 인스턴스에서 `__proto__`라는 프로퍼티를 통해 각 메서드에 접근할 수 있음
(이 때의 `__proto__` 생략 가능, 마치 자신의 것처럼 메서드를 호출할 수 있음)

### 프로토타입 체이닝

### 싱글 스레드

자바스크립트는 `싱글 스레드 기반`으로, `콜백 큐`를 사용한다.
자바스크립트의 호출 스택은 하나, 따라서 `한번에 한 작업만 처리`할 수 있다.
함수를 실행하면 해당 함수는 호출 스택의 가장 상단에 있으며
실행이 끝나면 (리턴 값을 돌려줌) 해당 함수를 호출 스택에서 제거한다.

만약 호출 스택에서 처리 시간이 어마어마하게 오래 걸리는 함수가 있다면,
해당 함수를 처리하는 동안 브라우저는 아무 작업도 못하는 대기 상태가 됨
이를 해결하기 위한 것이 바로 `비동기 콜백`

### 이벤트 루프, 자바스크립트의 동시성

동시성에 대한 처리는 브라우저나 node.js같은 자바스크립트 엔진 구동 환경이 담당한다.
자바스크립트 구동 환경에선 여러개의 스레드가 사용된다.
이러한 구동 환경이 싱글 스레드를 사용하는 자바스크립트 엔진과 상호 연동하기 위해 사용하는 장치가 바로 이벤트 루프.
`태스크 큐`는 콜백 함수들이 대기하는 큐(FIFO) 형태의 배열.
`이벤트 루프`는 호출 스택이 비워질 때마다 큐에서 콜백 함수를 꺼내와서 실행한다.
이벤트 루프는 `현재 실행중인 태스크가 없는지`와 `태스크 큐에 태스크가 있는지`를 반복적으로 확인한다. (그래서 loop)

- 모든 비동기 API들은 작업이 완료될 경우 콜백 함수를 태스크 큐에 추가함
- 이벤트 루프는 현재 실행중인 태스크가 없을때 (호출 스택이 비워졌을 때) 태스크 큐의 첫번쨰 태스크를 꺼내와 실행한다.

### 실행 컨텍스트

스코프는 함수가 정의될 때 결정, 실행 컨텍스트는 `함수가 실행될 때` 생성된다.
실행 컨텍스트에는 `호이스팅, this 바인딩, 스코프` 등의 정보가 담김
내부적으로 해당 함수를 실행하기 위해 필요한 정보를 모아둔 하나의 집합체.

자바스크립트의 코드들이 실행되기 위한 환경.
`전역 컨텍스트`, `함수 컨텍스트` 2가지가 존재.
`전역 컨텍스트` 하나가 생성되고 함수 호출할때마다 함수 컨텐스트가 생성

### 호이스팅

변수 선언과 함수 선언을 끌어올림. (할당 x)
자바스크립트 엔진은 코드를 실행하기 전에 코드 전반에 거쳐서 선언된 내용이 있는지를 확인하고 발견하는 족족 위로 끌어올림

### 브라우저의 동작 원리

1. 브라우저가 서버로부터 HTML, CSS, Javascript, 이미지 파일 등을 응답받으면
2. 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱되어 DOM과 CSSOM 트리로 변환되어 렌더 트리(시각적 속성 정보를 가짐)로 결합
   이것을 기반으로 웹페이지를 표기한다.

3. 자바스크립트의 경우 렌더링 엔진이 아닌 자바스크립트 엔진이 처리
   HTML 파서는 script 태그를 만나면 자바스크립트 코드 처리를 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘김
4. 자바스크립트 파일을 로드하고 파싱하여 실행
5. 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨 브라우저가 중지한 시점부터 DOM 생성을 재개

자바스크립트는 동기적으로 이러한 과정을 처리하기 때문에 script 태그 위치에 따라 블로킹이 발생하여 DOM 생성이 지연될 수 있음
DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작할 경우 에러 발생

### 브라우저의 동작 원리(재정리)

1. DOM Tree 생성 : 브라우저가 HTML을 전달받으면 브라우저의 렌더 엔진이 이를 파싱하여 DOM 노드로 이뤄진 트리를 만듬.
2. Render Tree 생성 : 외부 CSS 파일과 각 엘리먼트의 inline 스타일을 파싱. 스타일 정보를 사용하여 DOM 트리에 따라 새로운 트리, 렌더트리를 생성
3. DOM 트리의 모든 노드들은 attach라는 메소드가 존재. (스타일 정보를 계산하여 객체 형태로 변환). DOM 트리에 새 노드가 추가되면 attach 메소드가 실행됨.
4. 렌더 트리가 다 만들어지면 레이아웃 과정을 거침 (reflow라고도 부름) 각 노드들은 좌표가 주어지며 위치가 주어짐
5. 이후엔 렌더링 된 요소들에 색을 입힘. 트리의 각 노드들을 거치면서 paint() 메소드 호출.
6. 스크린에 원하는 정보가 나타남.

### Virtual dom
복잡한 SPA에선 DOM 조작이 많이 발생함. 변화 적용을 위해 브라우저가 많은 연산을 해야하기 때문에 비효율적여짐.

Virtual dom은 뷰에 변화가 있다면 가상 dom에 해당 변화를 적용시키고 가상 dom과 현재 내용을 비교하여 바뀐 부분만을 실제 dom으로 전달시켜줌.

### Reflow와 Repaint

수정된 렌더트리를 다시 렌더링 하는 과정에서 발생.
웹 어플리케이션의 성능을 떨어뜨림

#### Reflow

엘리먼트의 위치 길이 등을 다시 계산하는 것.
문서의 일부 혹은 전체를 다시 렌더링함

- DOM 엘리먼트 추가 제거 변경
- CSS 스타일 추가 제거 변경
- CSS 애니메이션과 트랜지션
- 유저 행동
- offsetWidth, offsetHeight의 사용
  으로 리플로우가 트리거 됨

#### Repaint

플로우를 통해 계산한 것을 그리는 과정.
레이아웃엔 영향을 주지 않지만 가시성에는 영향을 주는 엘리먼트가 변경되면 발생.
opacity, background-color, visibility, outline 등

### async, defer

외부 스크립트를 불러올 때 사용할 수 있는 속성

```
<script defer src="script.js>
```

`defer` 속성을 가진 스크립트는 브라우저가 `<script defer>`를 만났을 때 다운로드를 시작하며, html 파싱은 막지 않고 `</html>`을 만났을 때 실행됨

```
<script async src="script.js>
```

`async` 속성을 가진 스크립트는 defer와 마찬가지로 브라우저가 해당 요소를 만났을 때 스크립트 다운로드를 실행.
다운로드 중에 HTML 파싱을 막지는 않지만 다운로드가 완료되면 즉시 실행하며 실행되는 동안 HTML 파싱을 멈춤.
async 속성 스크립트에선 DOM을 조작하지 않으며 앞 뒤 로드될 스크립트와 의존성을 갖고 있지 않은 코드를 포함

defer와 async속성 두가지 모두 일부 브라우저에서 지원하지 않기 때문에 주의해야 함

### 배열과 리스트 차이

#### 배열

- 같은 자료형을 가진 변수를 하나로 나타낸 것
- 연속된 메모리 공간으로 이루어져 있음
- 정적 표현
- 인덱스를 이용하여 표현
- 지역성을 가지고 있음

=> 데이터 크기가 정해져 있고 추가 삽입/삭제가 발생하지 않으며 검색을 필요로 할 때 유리

#### 리스트

- 순서가 있는 데이터의 집합
- 불연속적으로 메모리 공간을 차지
- 동적 표현
- 인덱스가 없음
- 포인터를 통한 접근

=> 데이터 크기가 정해져 있지 않고 삽입/삭제가 많이 발생하며 검색이 적을 때 유리

### Set, Map

- set : 중복을 허용하지 않는 데이터 집합
- map : 객체와 유사하나, 키에 다양한 자료형을 허용한다는 차이가 있음


### E2E? 유닛 테스트

### 리액트에서 훅스를 도입한 이유?

#### 훅스의 장점
- 응집성과 조립 가능성 (훅을 사용하면 생산성이 높아짐, 재활용 가능)
- Wrapper Hell 방지
- 라이프사이클 메서드보다 단순 (useState & useEffect 조합으로 표현)

#### 단점
- 미지원 기능 (getSnapshotBeforeUpdate, componentDidCatch 지원 x)
- 클래스에서 사용 불가
- 의존성 증가
- 훅 사용의 유의점 (어떤 조건문으로도 감싸지 않고 항상 순서대로 호출, 다양한 종류의 훅을 다시 배워야 함)

### 함수형 컴포넌트의 장점

### Promise의 메소드 정리
- then : 두 개의 콜백 함수를 인자로 전달 받음. 첫 번째 콜백 함수는 성공(fulfilled, resolve 함수가 호출된 상태) 시 호출, 두 번째 함수는 실패(rejected, reject 함수가 호출된 상태) 시 호출.
- catch : 예외(비동기 처리에서 발생한 에러와 then 메소드에서 발생한 에러)가 발생하면 호출. catch 메소드는 Promise를 반환.
- resolve : 인자로 전달된 값을 resolve하는 Promise를 생성.
- reject : 인자로 전달된 값을 reject하는 프로미스를 생성.
- all : 프로미스가 담겨 있는 배열 등의 이터러블을 인자로 전달 받음. 그리고 전달받은 모든 프로미스를 병렬로 처리하고 그 처리 결과를 resolve하는 새로운 프로미스를 반환.
- race : Promise.all 메소드와 동일하게 프로미스가 담겨 있는 배열 등의 이터러블을 인자로 전달 받음. 그리고 Promise.race 메소드는 Promise.all 메소드처럼 모든 프로미스를 병렬 처리하는 것이 아니라 가장 먼저 처리된 프로미스가 resolve한 처리 결과를 resolve하는 새로운 프로미스를 반환.

### styled components의 도입 이유

### css 애니메이션과 js 애니메이션의 장단점
