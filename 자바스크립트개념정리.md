# 자바스크립트

## 자바스크립트의 개념 이해

### 자바스크립트의 특징

1. 자바스크립트는 `프토토타입 기반의 객체 기반의 언어`다.
2. 자바스크립트는 `인터프리터 언어`(개발자가 별도의 컴파일 작업을 수행하지 않음)로써, 브라우저에 의해 해석되고 실행된다.
3. `등적 형변환` (값에 따라 변수의 형변환이 자동으로 이루어진다.)
4. `객체 지향형 프로그래밍`, `함수형 프로그래밍`을 모두 표현할 수 있다.
5. 기본적으로 위에서 아래의 순서로 진행한다.
6. 웹에 특화된 언어이다.

### 자바스크립트의 데이터 타입

기본(원시적) 타입: 숫자(Number), 문자열(String), 참거짓(Boolean), null, undefined, (symbol)
참조 타입: 객체, 배열, 함수
(참조 타입은 크기가 가변적이며 변수에는 데이터에 대한 참조만 저장됨)

### 변수 선언

var : `함수`를 기준으로 스코프를 가진다.
let/const : `블록`을 기준으로 스코프를 가진다.

### 클로저

클로저란, 내부 함수가 외부 함수의 맥락(context)에 접근할 수 있는 것을 의미한다.

```
const func = () => {
    let name = '지인';
    const showName = () => {
        alert(name);
    }
    return showName;
}

const startFunc = func();
startFunc(); //name 변수에 접근하여 지인을 alert으로 띄움
```

함수 내부의 지역 변수들은 해당 함수가 처리되는 동안에만 존재하지만, 자바스크립트에서 함수를 리턴하게 되면 클로저가 형성될 당시의 함수, 함수가 선언된 어휘의 환경 조합의 참조를 기억한다.

### 프로토타입 (중요)

자바스크립트는 `프로토타입 기반의` 객체지향 언어.
클래스 기반의 객체지향 언어는 객체 생성 이전에 클래스를 저의하고 이를 통하여 객체를 생성함.
프로토타입 기반의 객체지향 프로그래밍 언어는 클래스 없이도 객체 생성이 가능하다.

자바스크립트의 모든 객체는 부모 역할을 담당하는 객체와 연결되어 있다.
이것은 객체 지향의 `상속`개념처럼 부모 객체의 프로퍼티, 메소드를 상속받아 사용할 수 있도록 한다.
이 부모 객체를 `프로토타입 객체`라고 한다.

생성자 함수가 있을 때 new 연산자를 써서 instance를 만들면 생성자 함수의 prototype이라고 하는 property가 instance 함수의 **proto** 라는 property에 전달이 된다.
즉 생성자 함수의 prototype과 instance의 **proto** 라는 property는 같은 객체를 참조.
**proto**는 내부 프로퍼티에 접근할 때 이 단어를 생략 가능. (prototype으로 동작하는 것으로 보임)

prototype property는 객체. (concat(), filter(), forEach(), map(), push(), pop()이 담겨 있음 = 배열 메서드)

#### 생성자 함수의 prototype에 접근하는 법

- [CONSTRUCTOR].prototype
- [instance].**proto**
- [instance]
- Object.getPrototypeOf([instance])
  <br/>

#### 생성자 함수에 접근하는 법

- [CONSTRUCTOR]
- [CONSTRUCTOR].prototype.constructor
- (Object.getPrototypeOf([instance])).constructor
- [instance].**proto**.constructor
- [instance].constructor

### 메소드 상속 및 동작 원리

```
function Person(n, a){
    this.name = n;
    this.age = a;
}
Person.prototype.setOlder = function() {
    this.age += 1;
}
Person prototype.getAge = function(){
    return this.age;
}

let jiin = new Person('지인', 58);
let baby = new Person('아기', 1);

jiin.__proto__.setOlder();
=> jiin.setOlder();
```

각 인스턴스에서 **proto**라는 프로퍼티를 통해 각 메서드에 접근할 수 있음
(이 때의 **proto** 생략 가능, 마치 자신의 것처럼 메서드를 호출할 수 있음)

### 프로토타입 체이닝

### 싱글 스레드

### 이벤트 루프

### 실행 컨텍스트

### 브라우저의 동작 원리

### E2E? 유닛 테스트

### 리액트에서 훅스를 도입한 이유?

### 함수형 컴포넌트의 장점

### Promise의 메소드 정리

### styled components의 도입 이유

### css 애니메이션과 js 애니메이션의 장단점
