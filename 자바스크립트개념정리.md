# 자바스크립트

## 자바스크립트의 개념 이해

### 자바스크립트의 특징

1. 자바스크립트는 `프토토타입 기반의 객체 기반의 언어`다.
2. 자바스크립트는 `인터프리터 언어`(개발자가 별도의 컴파일 작업을 수행하지 않음)로써, 브라우저에 의해 해석되고 실행된다.
3. `등적 형변환` (값에 따라 변수의 형변환이 자동으로 이루어진다.)
4. `객체 지향형 프로그래밍`, `함수형 프로그래밍`을 모두 표현할 수 있다.
5. 기본적으로 위에서 아래의 순서로 진행한다.
6. 웹에 특화된 언어이다.

### 자바스크립트의 데이터 타입

기본(원시적) 타입: 숫자(Number), 문자열(String), 참거짓(Boolean), null, undefined, (symbol)

참조 타입: 객체, 배열, 함수
(참조 타입은 크기가 가변적이며 변수에는 데이터에 대한 참조만 저장됨)

다른 언어에는 숫자 타입이 다양하지만 자바스크립트엔 number 하나만 있음
정수만을 위한 타입이 없고 모든 수를 실수로 처리

### 변수 선언

var : `함수`를 기준으로 스코프를 가진다.
let/const : `블록`을 기준으로 스코프를 가진다.

### THIS

전역공간에서 this는 `전역객체`를 가리킨다. 브라우저에선 window , node.js에선 global
함수 내부에서 역시 `전역객체`
메소드 호출 시 `메소드를 호출한 주체`
콜백에선 기본적으론 `함수내부에서와 동일`
생성자 함수에선 `인스턴스`

화살표 함수에서의 THIS?

### 클로저

클로저란, 내부 함수가 외부 함수의 맥락(context)에 접근할 수 있는 것을 의미한다.

```
const func = () => {
    let name = '지인';
    const showName = () => {
        alert(name);
    }
    return showName;
}

const startFunc = func();
startFunc(); //name 변수에 접근하여 지인을 alert으로 띄움
```

함수 내부의 지역 변수들은 해당 함수가 처리되는 동안에만 존재하지만, 자바스크립트에서 함수를 리턴하게 되면 클로저가 형성될 당시의 함수, 함수가 선언된 어휘의 환경 조합의 참조를 기억한다.

### 프로토타입 (중요)

자바스크립트는 `프로토타입 기반의` 객체지향 언어.
클래스 기반의 객체지향 언어는 객체 생성 이전에 클래스를 저의하고 이를 통하여 객체를 생성함.
프로토타입 기반의 객체지향 프로그래밍 언어는 클래스 없이도 객체 생성이 가능하다.

자바스크립트의 모든 객체는 부모 역할을 담당하는 객체와 연결되어 있다.
이것은 객체 지향의 `상속`개념처럼 부모 객체의 프로퍼티, 메소드를 상속받아 사용할 수 있도록 한다.
이 부모 객체를 `프로토타입 객체`라고 한다.

생성자 함수가 있을 때 new 연산자를 써서 instance를 만들면 생성자 함수의 prototype이라고 하는 property가 instance 함수의 `__proto__` 라는 property에 전달이 된다.
즉 생성자 함수의 prototype과 instance의 `__proto__` 라는 property는 같은 객체를 참조.
`__proto__`는 내부 프로퍼티에 접근할 때 이 단어를 생략 가능. (prototype으로 동작하는 것으로 보임)

prototype property는 객체. (concat(), filter(), forEach(), map(), push(), pop()이 담겨 있음 = 배열 메서드)

#### 생성자 함수의 prototype에 접근하는 법

- [CONSTRUCTOR].prototype
- [instance].`__proto__`
- [instance]
- Object.getPrototypeOf([instance])
  <br/>

#### 생성자 함수에 접근하는 법

- [CONSTRUCTOR]
- [CONSTRUCTOR].prototype.constructor
- (Object.getPrototypeOf([instance])).constructor
- [instance].`__proto__`.constructor
- [instance].constructor

### 메소드 상속 및 동작 원리

```
function Person(n, a){
    this.name = n;
    this.age = a;
}
Person.prototype.setOlder = function() {
    this.age += 1;
}
Person prototype.getAge = function(){
    return this.age;
}

let jiin = new Person('지인', 58);
let baby = new Person('아기', 1);

jiin.__proto__.setOlder();
=> jiin.setOlder();
```

각 인스턴스에서 `__proto__`라는 프로퍼티를 통해 각 메서드에 접근할 수 있음
(이 때의 `__proto__` 생략 가능, 마치 자신의 것처럼 메서드를 호출할 수 있음)

### 프로토타입 체이닝

### 싱글 스레드

자바스크립트는 `싱글 스레드 기반`으로, `콜백 큐`를 사용한다.
자바스크립트의 호출 스택은 하나, 따라서 `한번에 한 작업만 처리`할 수 있다.
함수를 실행하면 해당 함수는 호출 스택의 가장 상단에 있으며
실행이 끝나면 (리턴 값을 돌려줌) 해당 함수를 호출 스택에서 제거한다.

만약 호출 스택에서 처리 시간이 어마어마하게 오래 걸리는 함수가 있다면,
해당 함수를 처리하는 동안 브라우저는 아무 작업도 못하는 대기 상태가 됨
이를 해결하기 위한 것이 바로 `비동기 콜백`

### 이벤트 루프, 자바스크립트의 동시성

동시성에 대한 처리는 브라우저나 node.js같은 자바스크립트 엔진 구동 환경이 담당한다.
자바스크립트 구동 환경에선 여러개의 스레드가 사용된다.
이러한 구동 환경이 싱글 스레드를 사용하는 자바스크립트 엔진과 상호 연동하기 위해 사용하는 장치가 바로 이벤트 루프.
`태스크 큐`는 콜백 함수들이 대기하는 큐(FIFO) 형태의 배열.
`이벤트 루프`는 호출 스택이 비워질 때마다 큐에서 콜백 함수를 꺼내와서 실행한다.
이벤트 루프는 `현재 실행중인 태스크가 없는지`와 `태스크 큐에 태스크가 있는지`를 반복적으로 확인한다. (그래서 loop)

- 모든 비동기 API들은 작업이 완료될 경우 콜백 함수를 태스크 큐에 추가함
- 이벤트 루프는 현재 실행중인 태스크가 없을때 (호출 스택이 비워졌을 때) 태스크 큐의 첫번쨰 태스크를 꺼내와 실행한다.

### 실행 컨텍스트

스코프는 함수가 정의될 때 결정, 실행 컨텍스트는 `함수가 실행될 때` 생성된다.
실행 컨텍스트에는 `호이스팅, this 바인딩, 스코프` 등의 정보가 담김
내부적으로 해당 함수를 실행하기 위해 필요한 정보를 모아둔 하나의 집합체.

자바스크립트의 코드들이 실행되기 위한 환경.
`전역 컨텍스트`, `함수 컨텍스트` 2가지가 존재.
`전역 컨텍스트` 하나가 생성되고 함수 호출할때마다 함수 컨텐스트가 생성

### 호이스팅

변수 선언과 함수 선언을 끌어올림. (할당 x)
자바스크립트 엔진은 코드를 실행하기 전에 코드 전반에 거쳐서 선언된 내용이 있는지를 확인하고 발견하는 족족 위로 끌어올림

### 브라우저의 동작 원리

1. 브라우저가 서버로부터 HTML, CSS, Javascript, 이미지 파일 등을 응답받으면
2. 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱되어 DOM과 CSSOM 트리로 변환되어 렌더 트리(시각적 속성 정보를 가짐)로 결합
   이것을 기반으로 웹페이지를 표기한다.

3. 자바스크립트의 경우 렌더링 엔진이 아닌 자바스크립트 엔진이 처리
   HTML 파서는 script 태그를 만나면 자바스크립트 코드 처리를 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘김
4. 자바스크립트 파일을 로드하고 파싱하여 실행
5. 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨 브라우저가 중지한 시점부터 DOM 생성을 재개

자바스크립트는 동기적으로 이러한 과정을 처리하기 때문에 script 태그 위치에 따라 블로킹이 발생하여 DOM 생성이 지연될 수 있음
DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작할 경우 에러 발생

### async, defer

외부 스크립트를 불러올 때 사용할 수 있는 속성

```
<script defer src="script.js>
```

`defer` 속성을 가진 스크립트는 브라우저가 `<script defer>`를 만났을 때 다운로드를 시작하며, html 파싱은 막지 않고 `</html>`을 만났을 때 실행됨

```
<script async src="script.js>
```

`async` 속성을 가진 스크립트는 defer와 마찬가지로 브라우저가 해당 요소를 만났을 때 스크립트 다운로드를 실행.
다운로드 중에 HTML 파싱을 막지는 않지만 다운로드가 완료되면 즉시 실행하며 실행되는 동안 HTML 파싱을 멈춤.
async 속성 스크립트에선 DOM을 조작하지 않으며 앞 뒤 로드될 스크립트와 의존성을 갖고 있지 않은 코드를 포함

defer와 async속성 두가지 모두 일부 브라우저에서 지원하지 않기 때문에 주의해야 함

### E2E? 유닛 테스트

### 리액트에서 훅스를 도입한 이유?

### 함수형 컴포넌트의 장점

### Promise의 메소드 정리

### styled components의 도입 이유

### css 애니메이션과 js 애니메이션의 장단점
